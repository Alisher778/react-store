'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Utils = function () {
  function Utils() {
    _classCallCheck(this, Utils);

    this.nopElement = _react2.default.createElement('span', null);
  }

  _createClass(Utils, [{
    key: 'forEachChild',
    value: function forEachChild(children, handler) {
      var _this = this;

      _react2.default.Children.forEach(children, function (child) {
        handler(child);

        if (child.props && child.props.children) {
          _this.forEachChild(child.props.children, handler);
        }
      });
    }
  }, {
    key: 'buildElementTree',
    value: function buildElementTree(element, optionsFactory, elementFactory, parent) {
      var _this2 = this;

      var newChildren = undefined;

      var newElement = elementFactory && elementFactory(element, parent) || element;
      var newOptions = optionsFactory && optionsFactory(element, parent) || {};

      if (newElement !== this.nopElement && newElement.props && newElement.props.children) {
        newChildren = _react2.default.Children.map(newElement.props.children, function (childElement) {
          if (!_react2.default.isValidElement(childElement)) {
            return elementFactory(childElement, parent);
          }
          return _this2.buildElementTree(childElement, optionsFactory, elementFactory, newElement);
        });
      }

      return _react2.default.cloneElement(newElement, newOptions, newChildren);
    }
  }, {
    key: 'getFormFieldMap',
    value: function getFormFieldMap(root, handler) {
      var fields = {};

      var tryMapField = function tryMapField(field, name) {
        if (field.props.ignore) {
          return;
        }

        if (field.props.fieldName) {
          name = elements.props.fieldName;
        }

        if (!('name' in fields)) {
          fields[name] = field;
        }
      };

      this.forEachChild(root, function (child) {
        if (!child.props) {
          return;
        }

        handler(child, tryMapField.bind(null, child));
      });

      var inverseMap = {};
      var defaultValues = {};

      for (var key in fields) {
        var field = fields[key];

        if (!(field.type in inverseMap)) {
          inverseMap[field.type] = {};
        }

        var defaultValue = field.props.value || '';
        defaultValues[key] = defaultValue;

        inverseMap[field.type][field.props.name] = {
          fieldName: key,
          field: field
        };
      }

      return {
        defaultValues: defaultValues,
        inverse: inverseMap
      };
    }
  }, {
    key: 'makeForm',
    value: function makeForm(source, fieldMapFn, showWhenFn, replaceWithFn) {
      var _this3 = this;

      var root = _react2.default.cloneElement(_react2.default.createElement('div', null), {}, source.props.children);

      var fieldMap = this.getFormFieldMap(root, fieldMapFn);

      source.state.fields = source.state.fields || {};
      for (var key in fieldMap.defaultValues) {
        if (!(key in source.state.fields)) {
          source.state.fields[key] = fieldMap.defaultValues[key];
        }
      }

      var elementFactory = function elementFactory(element, parent) {
        if (element.props) {
          var showWhen = element.props.showWhen;

          if (showWhen) {
            var test = null;
            var inverted = false;

            if (showWhen[0] === '!') {
              inverted = true;
              showWhen = showWhen.substr(1);
            }

            test = showWhenFn(showWhen, element);

            if (test !== null) {
              if (inverted) {
                test = !test;
              }

              if (!test) {
                return _this3.nopElement;
              }
            }
          }

          var replaceWith = element.props.replaceWith;

          if (replaceWith) {
            var newElement = replaceWithFn(replaceWith, element);
            if (newElement !== false) {
              element = newElement;
            }
          }
        }
        return element;
      };

      var optionsFactory = function optionsFactory(element, parent) {
        var options = {};

        if (element.props) {
          var elementType = element.type;
          var elementAttributeName = element.props.name;

          if (elementType in fieldMap.inverse && elementAttributeName in fieldMap.inverse[elementType]) {
            var mappedField = fieldMap.inverse[elementType][elementAttributeName];
            options.onChange = function (e) {
              disabled: source.state.isFormProcessing;
              source.state.fields[mappedField.fieldName] = e.target.value;
            };
          }

          var elementAttributeType = element.props.type;

          if ((elementType === 'input' || elementType === 'button') && elementAttributeType === 'submit') {
            options.disabled = source.state.isFormProcessing;
          }
        }

        return options;
      };

      return this.buildElementTree(root, optionsFactory, elementFactory);
    }
  }]);

  return Utils;
}();

exports.default = new Utils();