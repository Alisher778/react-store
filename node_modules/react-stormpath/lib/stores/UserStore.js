'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _app = require('../app');

var _app2 = _interopRequireDefault(_app);

var _BaseStore2 = require('../stores/BaseStore');

var _BaseStore3 = _interopRequireDefault(_BaseStore2);

var _UserService = require('../services/UserService');

var _UserService2 = _interopRequireDefault(_UserService);

var _UserConstants = require('../constants/UserConstants');

var _UserConstants2 = _interopRequireDefault(_UserConstants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _session = false;
var _sessionError = null;
var _sessionResolved = false;

var UserStore = function (_BaseStore) {
  _inherits(UserStore, _BaseStore);

  function UserStore() {
    _classCallCheck(this, UserStore);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(UserStore).call(this));

    _this.service = null;
    return _this;
  }

  _createClass(UserStore, [{
    key: 'init',
    value: function init(context) {
      this.service = new _UserService2.default(context.getEndpoints());
      this.resolveSession();
    }
  }, {
    key: 'getSession',
    value: function getSession() {
      return _session;
    }
  }, {
    key: 'isAuthenticated',
    value: function isAuthenticated(callback) {
      this.resolveSession(function (err, result) {
        callback(err, !err && _session !== false);
      });
    }
  }, {
    key: 'login',
    value: function login(options, callback) {
      var self = this;

      this.reset();

      this.service.login(options, function (err, result) {
        if (err) {
          return callback(err);
        }

        self.resolveSession(callback);
      });
    }
  }, {
    key: 'register',
    value: function register(options, callback) {
      this.service.register(options, callback);
    }
  }, {
    key: 'forgotPassword',
    value: function forgotPassword(options, callback) {
      this.service.forgotPassword(options, callback);
    }
  }, {
    key: 'changePassword',
    value: function changePassword(options, callback) {
      this.service.changePassword(options, callback);
    }
  }, {
    key: 'verifyEmail',
    value: function verifyEmail(spToken, callback) {
      this.service.verifyEmail(spToken, callback);
    }
  }, {
    key: 'logout',
    value: function logout(callback) {
      var self = this;

      this.service.logout(function (err) {
        if (err) {
          return callback(err);
        }

        self.reset();
        self.emitChange();

        callback();
      });
    }
  }, {
    key: 'resolveSession',
    value: function resolveSession(callback) {
      var self = this;

      if (_sessionResolved) {
        return callback && callback(_sessionError, _session);
      }

      this.service.me(function (err, result) {
        self.reset();

        _sessionResolved = true;

        if (err) {
          _sessionError = err;
        } else {
          _session = result;
        }

        if (callback) {
          callback(_sessionError, _session);
        }

        self.emitChange();
      });
    }
  }, {
    key: 'reset',
    value: function reset(resolved) {
      _session = false;
      _sessionError = null;
      _sessionResolved = false;
    }
  }]);

  return UserStore;
}(_BaseStore3.default);

var userStore = new UserStore();

_app2.default.on('ready', function (context) {
  userStore.init(context);
  context.getDispatcher().register(function (payload) {
    switch (payload.actionType) {
      case _UserConstants2.default.USER_LOGIN:
        userStore.login(payload.options, payload.callback);
        break;
      case _UserConstants2.default.USER_LOGOUT:
        userStore.logout(payload.callback);
        break;
      case _UserConstants2.default.USER_REGISTER:
        userStore.register(payload.options, payload.callback);
        break;
      case _UserConstants2.default.USER_FORGOT_PASSWORD:
        userStore.forgotPassword(payload.options, payload.callback);
        break;
      case _UserConstants2.default.USER_CHANGE_PASSWORD:
        userStore.changePassword(payload.options, payload.callback);
        break;
      case _UserConstants2.default.USER_VERIFY_EMAIL:
        userStore.verifyEmail(payload.options.spToken, payload.callback);
        break;
    }
    return true;
  });
});

module.exports = userStore;